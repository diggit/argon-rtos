<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Argon RTOS: Ar::Thread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Argon RTOS
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">Tiny embedded real-time kernel</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_ar_1_1_thread.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_ar_1_1_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ar::Thread Class Reference<div class="ingroups"><a class="el" href="group__ar.html">Argon RTOS</a> &raquo; <a class="el" href="group__ar__thread.html">Threads</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ar__classes_8h_source.html">ar_classes.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ar::Thread:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_ar_1_1_thread__inherit__graph.png" border="0" usemap="#_ar_1_1_thread_inherit__map" alt="Inheritance graph"/></div>
<map name="_ar_1_1_thread_inherit__map" id="_ar_1_1_thread_inherit__map">
<area shape="rect" id="node3" href="class_ar_1_1_thread_with_stack.html" title="Template to create a thread and its stack. " alt="" coords="5,152,182,177"/>
<area shape="rect" id="node2" href="struct__ar__thread.html" title="Thread. " alt="" coords="49,5,138,31"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Preemptive thread class. </p>
<p>This thread class implements a preemptive thread with variable priority.</p>
<p>Threads may be allocated either globally or with the new operator. You can also allocate a thread locally, but you must be careful to keep the stack valid as long as the thread is running. There are two options for initialization. Either use one of the non-default constructors, or use the default constructor and call an <a class="el" href="class_ar_1_1_thread.html#a545e5245ed44184e9ad54db769626258" title="Base initialiser. ">init()</a> method at some later point. Both the constructors and init methods take the same arguments. They accept a name, entry point, stack, and priority.</p>
<p>The entry point can be a global or static function that matches the <a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6" title="Prototype for the thread entry point. ">ar_thread_entry_t</a> prototype. Alternatively, there are constructor and <a class="el" href="class_ar_1_1_thread.html#a545e5245ed44184e9ad54db769626258" title="Base initialiser. ">init()</a> variants that let you use a member function of a specific object as the entry point.</p>
<p>The <a class="el" href="class_ar_1_1_thread.html#a545e5245ed44184e9ad54db769626258" title="Base initialiser. ">init()</a> method leaves the new thread suspended. To make the new thread eligible to run you must call the <a class="el" href="class_ar_1_1_thread.html#a83520b6fe067f7fa57addca8b6943716" title="Make the thread eligible for execution. ">resume()</a> method on it. </p>
</div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for Ar::Thread:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_ar_1_1_thread__coll__graph.png" border="0" usemap="#_ar_1_1_thread_coll__map" alt="Collaboration graph"/></div>
<map name="_ar_1_1_thread_coll__map" id="_ar_1_1_thread_coll__map">
<area shape="rect" id="node2" href="struct__ar__thread.html" title="Thread. " alt="" coords="5,5,95,31"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27d5015db1c02a1b1d31f2fe9f78d6dc"><td class="memItemLeft" align="right" valign="top"><a id="a27d5015db1c02a1b1d31f2fe9f78d6dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a27d5015db1c02a1b1d31f2fe9f78d6dc">Thread</a> ()</td></tr>
<tr class="memdesc:a27d5015db1c02a1b1d31f2fe9f78d6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a27d5015db1c02a1b1d31f2fe9f78d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5d2547ef3ae17806dbb7ad297cee1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a1d5d2547ef3ae17806dbb7ad297cee1c">Thread</a> (const char *name, <a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a> entry, void *param, void *stack, unsigned stackSize, uint8_t priority, bool startImmediately=true)</td></tr>
<tr class="memdesc:a1d5d2547ef3ae17806dbb7ad297cee1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a1d5d2547ef3ae17806dbb7ad297cee1c">More...</a><br /></td></tr>
<tr class="separator:a1d5d2547ef3ae17806dbb7ad297cee1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260f10aaea4b22be8e5ce1e7ddb13b91"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a260f10aaea4b22be8e5ce1e7ddb13b91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a260f10aaea4b22be8e5ce1e7ddb13b91">Thread</a> (const char *name, T *object, void(T::*entry)(), void *stack, unsigned stackSize, uint8_t priority, bool startImmediately=true)</td></tr>
<tr class="memdesc:a260f10aaea4b22be8e5ce1e7ddb13b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to set the thread entry to a member function.  <a href="#a260f10aaea4b22be8e5ce1e7ddb13b91">More...</a><br /></td></tr>
<tr class="separator:a260f10aaea4b22be8e5ce1e7ddb13b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cd21981509c9ca4d90256902d0b9f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a06cd21981509c9ca4d90256902d0b9f1">Thread</a> (const char *name, <a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a> entry, void *param, unsigned stackSize, uint8_t priority, bool startImmediately=true)</td></tr>
<tr class="memdesc:a06cd21981509c9ca4d90256902d0b9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to dynamically allocate the stack.  <a href="#a06cd21981509c9ca4d90256902d0b9f1">More...</a><br /></td></tr>
<tr class="separator:a06cd21981509c9ca4d90256902d0b9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95424304953391ff7aceb969a6d31fc5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a95424304953391ff7aceb969a6d31fc5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a95424304953391ff7aceb969a6d31fc5">Thread</a> (const char *name, T *object, void(T::*entry)(), unsigned stackSize, uint8_t priority, bool startImmediately=true)</td></tr>
<tr class="memdesc:a95424304953391ff7aceb969a6d31fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to set the thread entry to a member function, using a dynamic stack.  <a href="#a95424304953391ff7aceb969a6d31fc5">More...</a><br /></td></tr>
<tr class="separator:a95424304953391ff7aceb969a6d31fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c41095aa633bda03b9923e15f9bcd"><td class="memItemLeft" align="right" valign="top"><a id="a2a3c41095aa633bda03b9923e15f9bcd"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a2a3c41095aa633bda03b9923e15f9bcd">~Thread</a> ()</td></tr>
<tr class="memdesc:a2a3c41095aa633bda03b9923e15f9bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a2a3c41095aa633bda03b9923e15f9bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b47903b428d51509b4e19b26a6860f3"><td class="memItemLeft" align="right" valign="top"><a id="a6b47903b428d51509b4e19b26a6860f3"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a6b47903b428d51509b4e19b26a6860f3">getName</a> () const</td></tr>
<tr class="memdesc:a6b47903b428d51509b4e19b26a6860f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's name. <br /></td></tr>
<tr class="separator:a6b47903b428d51509b4e19b26a6860f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread init and cleanup</div></td></tr>
<tr class="memitem:a545e5245ed44184e9ad54db769626258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a545e5245ed44184e9ad54db769626258">init</a> (const char *name, <a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a> entry, void *param, void *stack, unsigned stackSize, uint8_t priority, bool startImmediately=true)</td></tr>
<tr class="memdesc:a545e5245ed44184e9ad54db769626258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base initialiser.  <a href="#a545e5245ed44184e9ad54db769626258">More...</a><br /></td></tr>
<tr class="separator:a545e5245ed44184e9ad54db769626258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc0953b0f60d54b73f0cc71bec8fd76"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acdc0953b0f60d54b73f0cc71bec8fd76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#acdc0953b0f60d54b73f0cc71bec8fd76">init</a> (const char *name, T *object, void(T::*entry)(), void *stack, unsigned stackSize, uint8_t priority, bool startImmediately=true)</td></tr>
<tr class="memdesc:acdc0953b0f60d54b73f0cc71bec8fd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer to set the thread entry to a member function.  <a href="#acdc0953b0f60d54b73f0cc71bec8fd76">More...</a><br /></td></tr>
<tr class="separator:acdc0953b0f60d54b73f0cc71bec8fd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Thread priority</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Accessors for the thread's priority. </p>
</div></td></tr>
<tr class="memitem:aecb2d3d46955e9bf7c2175457434970e"><td class="memItemLeft" align="right" valign="top"><a id="aecb2d3d46955e9bf7c2175457434970e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#aecb2d3d46955e9bf7c2175457434970e">getPriority</a> () const</td></tr>
<tr class="memdesc:aecb2d3d46955e9bf7c2175457434970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread's current priority. <br /></td></tr>
<tr class="separator:aecb2d3d46955e9bf7c2175457434970e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305a4155b282edbc7c995b956770d277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a305a4155b282edbc7c995b956770d277">setPriority</a> (uint8_t priority)</td></tr>
<tr class="memdesc:a305a4155b282edbc7c995b956770d277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the thread's priority.  <a href="#a305a4155b282edbc7c995b956770d277">More...</a><br /></td></tr>
<tr class="separator:a305a4155b282edbc7c995b956770d277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Info</div></td></tr>
<tr class="memitem:a45ccaccadeab6e6fa156f2f717bd31e8"><td class="memItemLeft" align="right" valign="top"><a id="a45ccaccadeab6e6fa156f2f717bd31e8"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a45ccaccadeab6e6fa156f2f717bd31e8">getLoad</a> ()</td></tr>
<tr class="memdesc:a45ccaccadeab6e6fa156f2f717bd31e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's system load. <br /></td></tr>
<tr class="separator:a45ccaccadeab6e6fa156f2f717bd31e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79985f5e8f3e8cc385f110a3fa481d5b"><td class="memItemLeft" align="right" valign="top"><a id="a79985f5e8f3e8cc385f110a3fa481d5b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a79985f5e8f3e8cc385f110a3fa481d5b">getStackUsed</a> ()</td></tr>
<tr class="memdesc:a79985f5e8f3e8cc385f110a3fa481d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's maximum stack usage. <br /></td></tr>
<tr class="separator:a79985f5e8f3e8cc385f110a3fa481d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_struct__ar__thread"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_struct__ar__thread')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="struct__ar__thread.html">ar_thread_t</a></td></tr>
<tr class="memitem:aa0ed89e9fda3235787c53d0a570d268a inherit pub_methods_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="aa0ed89e9fda3235787c53d0a570d268a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>block</b> (<a class="el" href="structar__list__t.html">ar_list_t</a> &amp;blockedList, uint32_t timeout)</td></tr>
<tr class="separator:aa0ed89e9fda3235787c53d0a570d268a inherit pub_methods_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2c887e9d39eb35e47604540d73f86a inherit pub_methods_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a2e2c887e9d39eb35e47604540d73f86a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unblockWithStatus</b> (<a class="el" href="structar__list__t.html">ar_list_t</a> &amp;blockedList, <a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> unblockStatus)</td></tr>
<tr class="separator:a2e2c887e9d39eb35e47604540d73f86a inherit pub_methods_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Static members to get system-wide information. </p>
</div></td></tr>
<tr class="memitem:a3225bd5af1d2511e718597295a604e31"><td class="memItemLeft" align="right" valign="top"><a id="a3225bd5af1d2511e718597295a604e31"></a>
static <a class="el" href="class_ar_1_1_thread.html">Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a3225bd5af1d2511e718597295a604e31">getCurrent</a> ()</td></tr>
<tr class="memdesc:a3225bd5af1d2511e718597295a604e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently running thread object. <br /></td></tr>
<tr class="separator:a3225bd5af1d2511e718597295a604e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8d519f0e4c800e0edc749af12d580671"><td class="memItemLeft" align="right" valign="top"><a id="a8d519f0e4c800e0edc749af12d580671"></a>
<a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a8d519f0e4c800e0edc749af12d580671">initForMemberFunction</a> (const char *name, void *object, <a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a> entry, void *memberPointer, uint32_t memberPointerSize, void *stack, unsigned stackSize, uint8_t priority, bool startImmediately)</td></tr>
<tr class="memdesc:a8d519f0e4c800e0edc749af12d580671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special init method to deal with member functions. <br /></td></tr>
<tr class="separator:a8d519f0e4c800e0edc749af12d580671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99112d3407395ff4bd1384039f6d90c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a99112d3407395ff4bd1384039f6d90c3">threadEntry</a> (void *param)</td></tr>
<tr class="memdesc:a99112d3407395ff4bd1384039f6d90c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual thread entry point.  <a href="#a99112d3407395ff4bd1384039f6d90c3">More...</a><br /></td></tr>
<tr class="separator:a99112d3407395ff4bd1384039f6d90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3e3791493e0a97b5ed96290e0caac54f"><td class="memTemplParams" colspan="2"><a id="a3e3791493e0a97b5ed96290e0caac54f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3e3791493e0a97b5ed96290e0caac54f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a3e3791493e0a97b5ed96290e0caac54f">member_thread_entry</a> (void *param)</td></tr>
<tr class="memdesc:a3e3791493e0a97b5ed96290e0caac54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template function to invoke a thread entry point that is a member function. <br /></td></tr>
<tr class="separator:a3e3791493e0a97b5ed96290e0caac54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1ba678da55a07a5aeeda2890efeebf"><td class="memItemLeft" align="right" valign="top"><a id="adf1ba678da55a07a5aeeda2890efeebf"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#adf1ba678da55a07a5aeeda2890efeebf">thread_entry</a> (void *param)</td></tr>
<tr class="memdesc:adf1ba678da55a07a5aeeda2890efeebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static thread entry callback to invoke the virtual method. <br /></td></tr>
<tr class="separator:adf1ba678da55a07a5aeeda2890efeebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3fce2c8f2aca3f5a70172b3ea893ee3b"><td class="memItemLeft" align="right" valign="top"><a id="a3fce2c8f2aca3f5a70172b3ea893ee3b"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a3fce2c8f2aca3f5a70172b3ea893ee3b">m_allocatedStack</a></td></tr>
<tr class="memdesc:a3fce2c8f2aca3f5a70172b3ea893ee3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically allocated stack. <br /></td></tr>
<tr class="separator:a3fce2c8f2aca3f5a70172b3ea893ee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f5449c0e65cf9c5890562c3dfa5855"><td class="memItemLeft" align="right" valign="top"><a id="a19f5449c0e65cf9c5890562c3dfa5855"></a>
<a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a19f5449c0e65cf9c5890562c3dfa5855">m_userEntry</a></td></tr>
<tr class="memdesc:a19f5449c0e65cf9c5890562c3dfa5855"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-specified thread entry point function. <br /></td></tr>
<tr class="separator:a19f5449c0e65cf9c5890562c3dfa5855"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Thread state</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp90c6d431dad6f9f20e0ff0247db6a205"></a>Control of and access to the thread state. </p>
</td></tr>
<tr class="memitem:a691d68343e01bae8e3b60d35efd4f1bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a691d68343e01bae8e3b60d35efd4f1bf">suspend</a> ()</td></tr>
<tr class="memdesc:a691d68343e01bae8e3b60d35efd4f1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put thread in suspended state.  <a href="#a691d68343e01bae8e3b60d35efd4f1bf">More...</a><br /></td></tr>
<tr class="separator:a691d68343e01bae8e3b60d35efd4f1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83520b6fe067f7fa57addca8b6943716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a83520b6fe067f7fa57addca8b6943716">resume</a> ()</td></tr>
<tr class="memdesc:a83520b6fe067f7fa57addca8b6943716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the thread eligible for execution.  <a href="#a83520b6fe067f7fa57addca8b6943716">More...</a><br /></td></tr>
<tr class="separator:a83520b6fe067f7fa57addca8b6943716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4b94b374b8eb766e518961a8eb7c40"><td class="memItemLeft" align="right" valign="top"><a id="a4c4b94b374b8eb766e518961a8eb7c40"></a>
<a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a4c4b94b374b8eb766e518961a8eb7c40">getState</a> () const</td></tr>
<tr class="memdesc:a4c4b94b374b8eb766e518961a8eb7c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current state of the thread. <br /></td></tr>
<tr class="separator:a4c4b94b374b8eb766e518961a8eb7c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0014db107847869b311cf4deaac5585"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#aa0014db107847869b311cf4deaac5585">sleep</a> (unsigned milliseconds)</td></tr>
<tr class="memdesc:aa0014db107847869b311cf4deaac5585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep for a certain amount of time.  <a href="#aa0014db107847869b311cf4deaac5585">More...</a><br /></td></tr>
<tr class="separator:aa0014db107847869b311cf4deaac5585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf437dfe1fce2f17ca5223e611352ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html#a9cf437dfe1fce2f17ca5223e611352ba">sleepUntil</a> (unsigned wakeup)</td></tr>
<tr class="memdesc:a9cf437dfe1fce2f17ca5223e611352ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep until a specific time.  <a href="#a9cf437dfe1fce2f17ca5223e611352ba">More...</a><br /></td></tr>
<tr class="separator:a9cf437dfe1fce2f17ca5223e611352ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_struct__ar__thread"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_struct__ar__thread')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="struct__ar__thread.html">ar_thread_t</a></td></tr>
<tr class="memitem:a998962c2d89de305b7dae2977daedc1b inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a998962c2d89de305b7dae2977daedc1b"></a>
ar_list_node_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a998962c2d89de305b7dae2977daedc1b">m_blockedNode</a></td></tr>
<tr class="memdesc:a998962c2d89de305b7dae2977daedc1b inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocked list node. <br /></td></tr>
<tr class="separator:a998962c2d89de305b7dae2977daedc1b inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19b649e5d6654a83bf0f85144f7d246 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="af19b649e5d6654a83bf0f85144f7d246"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#af19b649e5d6654a83bf0f85144f7d246">m_channelData</a></td></tr>
<tr class="memdesc:af19b649e5d6654a83bf0f85144f7d246 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive or send data pointer for blocked channel. <br /></td></tr>
<tr class="separator:af19b649e5d6654a83bf0f85144f7d246 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300340297ad94a10ad0ead93d3a90da5 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a300340297ad94a10ad0ead93d3a90da5"></a>
<a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a300340297ad94a10ad0ead93d3a90da5">m_entry</a></td></tr>
<tr class="memdesc:a300340297ad94a10ad0ead93d3a90da5 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer for the thread's entry point. <br /></td></tr>
<tr class="separator:a300340297ad94a10ad0ead93d3a90da5 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2029a84a6bd82b2f60461201473f9c inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a7f2029a84a6bd82b2f60461201473f9c"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a7f2029a84a6bd82b2f60461201473f9c">m_name</a></td></tr>
<tr class="memdesc:a7f2029a84a6bd82b2f60461201473f9c inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread name. <br /></td></tr>
<tr class="separator:a7f2029a84a6bd82b2f60461201473f9c inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b06c5f335423e57f28969d597a9f59 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a74b06c5f335423e57f28969d597a9f59"></a>
ar_thread_port_data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a74b06c5f335423e57f28969d597a9f59">m_portData</a></td></tr>
<tr class="memdesc:a74b06c5f335423e57f28969d597a9f59 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Port-specific thread data. <br /></td></tr>
<tr class="separator:a74b06c5f335423e57f28969d597a9f59 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2cb7b4074ab1b821c33306fcaa6a67 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a1c2cb7b4074ab1b821c33306fcaa6a67"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a1c2cb7b4074ab1b821c33306fcaa6a67">m_priority</a></td></tr>
<tr class="memdesc:a1c2cb7b4074ab1b821c33306fcaa6a67 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread priority. 0 is the lowest priority. <br /></td></tr>
<tr class="separator:a1c2cb7b4074ab1b821c33306fcaa6a67 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e35e510129e9f872c3a6bab5454578 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a62e35e510129e9f872c3a6bab5454578"></a>
ar_runloop_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a62e35e510129e9f872c3a6bab5454578">m_runLoop</a></td></tr>
<tr class="memdesc:a62e35e510129e9f872c3a6bab5454578 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run loop associated with this thread. <br /></td></tr>
<tr class="separator:a62e35e510129e9f872c3a6bab5454578 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924854ea9389029b62c37594d3667723 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a924854ea9389029b62c37594d3667723"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a924854ea9389029b62c37594d3667723">m_stackBottom</a></td></tr>
<tr class="memdesc:a924854ea9389029b62c37594d3667723 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Beginning of stack. <br /></td></tr>
<tr class="separator:a924854ea9389029b62c37594d3667723 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1370ddb9050c39271324f45653c372e7 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a1370ddb9050c39271324f45653c372e7"></a>
volatile uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a1370ddb9050c39271324f45653c372e7">m_stackPointer</a></td></tr>
<tr class="memdesc:a1370ddb9050c39271324f45653c372e7 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current stack pointer. <br /></td></tr>
<tr class="separator:a1370ddb9050c39271324f45653c372e7 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6067469b3a97eec155658bd5130ecd0e inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a6067469b3a97eec155658bd5130ecd0e"></a>
uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a6067469b3a97eec155658bd5130ecd0e">m_stackTop</a></td></tr>
<tr class="memdesc:a6067469b3a97eec155658bd5130ecd0e inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saved stack top address for computing stack usage. <br /></td></tr>
<tr class="separator:a6067469b3a97eec155658bd5130ecd0e inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5153c6dfb5d553d42ce9503e68e299f7 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a5153c6dfb5d553d42ce9503e68e299f7"></a>
<a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a5153c6dfb5d553d42ce9503e68e299f7">m_state</a></td></tr>
<tr class="memdesc:a5153c6dfb5d553d42ce9503e68e299f7 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current thread state. <br /></td></tr>
<tr class="separator:a5153c6dfb5d553d42ce9503e68e299f7 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8321b10d058c9b93ff0e6c3dbd8b502 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="ae8321b10d058c9b93ff0e6c3dbd8b502"></a>
ar_list_node_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#ae8321b10d058c9b93ff0e6c3dbd8b502">m_threadNode</a></td></tr>
<tr class="memdesc:ae8321b10d058c9b93ff0e6c3dbd8b502 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main thread list node. <br /></td></tr>
<tr class="separator:ae8321b10d058c9b93ff0e6c3dbd8b502 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558dfc7bb4b89ca507114b0f0f093b7a inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a558dfc7bb4b89ca507114b0f0f093b7a"></a>
<a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a558dfc7bb4b89ca507114b0f0f093b7a">m_unblockStatus</a></td></tr>
<tr class="memdesc:a558dfc7bb4b89ca507114b0f0f093b7a inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status code to return from a blocking function upon unblocking. <br /></td></tr>
<tr class="separator:a558dfc7bb4b89ca507114b0f0f093b7a inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e06c59329551be8aade2fdea4eb162 inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="aa4e06c59329551be8aade2fdea4eb162"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#aa4e06c59329551be8aade2fdea4eb162">m_uniqueId</a></td></tr>
<tr class="memdesc:aa4e06c59329551be8aade2fdea4eb162 inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique ID for this thread. <br /></td></tr>
<tr class="separator:aa4e06c59329551be8aade2fdea4eb162 inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ae18d08fb8135eeb6003aa0ccac97d inherit pub_attribs_struct__ar__thread"><td class="memItemLeft" align="right" valign="top"><a id="a99ae18d08fb8135eeb6003aa0ccac97d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html#a99ae18d08fb8135eeb6003aa0ccac97d">m_wakeupTime</a></td></tr>
<tr class="memdesc:a99ae18d08fb8135eeb6003aa0ccac97d inherit pub_attribs_struct__ar__thread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick count when a sleeping thread will awaken. <br /></td></tr>
<tr class="separator:a99ae18d08fb8135eeb6003aa0ccac97d inherit pub_attribs_struct__ar__thread"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1d5d2547ef3ae17806dbb7ad297cee1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5d2547ef3ae17806dbb7ad297cee1c">&#9670;&nbsp;</a></span>Thread() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startImmediately</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">entry</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> entry point taking one parameter and returning void. </td></tr>
    <tr><td class="paramname">param</td><td>Arbitrary pointer-sized value passed as the single parameter to the thread entry point. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
    <tr><td class="paramname">startImmediately</td><td>Whether the new thread will start to run automatically. If false, the thread will be created in a suspended state. The constants <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281a590fa4384d5ccce48ffaa15e5a81c973" title="Automatically run the thread. ">kArStartThread</a> and <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281ab4226c477d1366a9f2b96e0e407b8590" title="Create the thread suspended. ">kArSuspendThread</a> can be used to better document this parameter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a260f10aaea4b22be8e5ce1e7ddb13b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260f10aaea4b22be8e5ce1e7ddb13b91">&#9670;&nbsp;</a></span>Thread() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startImmediately</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to set the thread entry to a member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to an instance of class T upon which the <em>entry</em> member function will be invoked when the thread is started. </td></tr>
    <tr><td class="paramname">entry</td><td>Member function of class T that will be used as the thread's entry point. The member function must take no parameters and return void. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
    <tr><td class="paramname">startImmediately</td><td>Whether the new thread will start to run automatically. If false, the thread will be created in a suspended state. The constants <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281a590fa4384d5ccce48ffaa15e5a81c973" title="Automatically run the thread. ">kArStartThread</a> and <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281ab4226c477d1366a9f2b96e0e407b8590" title="Create the thread suspended. ">kArSuspendThread</a> can be used to better document this parameter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06cd21981509c9ca4d90256902d0b9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cd21981509c9ca4d90256902d0b9f1">&#9670;&nbsp;</a></span>Thread() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startImmediately</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to dynamically allocate the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">entry</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> entry point taking one parameter and returning void. </td></tr>
    <tr><td class="paramname">param</td><td>Arbitrary pointer-sized value passed as the single parameter to the thread entry point. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space to allocate via <code>new</code> to the thread. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
    <tr><td class="paramname">startImmediately</td><td>Whether the new thread will start to run automatically. If false, the thread will be created in a suspended state. The constants <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281a590fa4384d5ccce48ffaa15e5a81c973" title="Automatically run the thread. ">kArStartThread</a> and <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281ab4226c477d1366a9f2b96e0e407b8590" title="Create the thread suspended. ">kArSuspendThread</a> can be used to better document this parameter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95424304953391ff7aceb969a6d31fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95424304953391ff7aceb969a6d31fc5">&#9670;&nbsp;</a></span>Thread() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ar::Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startImmediately</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor to set the thread entry to a member function, using a dynamic stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to an instance of class T upon which the <em>entry</em> member function will be invoked when the thread is started. </td></tr>
    <tr><td class="paramname">entry</td><td>Member function of class T that will be used as the thread's entry point. The member function must take no parameters and return void. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space to allocate via <code>new</code> to the thread. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
    <tr><td class="paramname">startImmediately</td><td>Whether the new thread will start to run automatically. If false, the thread will be created in a suspended state. The constants <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281a590fa4384d5ccce48ffaa15e5a81c973" title="Automatically run the thread. ">kArStartThread</a> and <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281ab4226c477d1366a9f2b96e0e407b8590" title="Create the thread suspended. ">kArSuspendThread</a> can be used to better document this parameter value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a545e5245ed44184e9ad54db769626258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545e5245ed44184e9ad54db769626258">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> Ar::Thread::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startImmediately</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base initialiser. </p>
<p>The thread is in suspended state when this method exits. To make it eligible for execution, call the <a class="el" href="class_ar_1_1_thread.html#a83520b6fe067f7fa57addca8b6943716" title="Make the thread eligible for execution. ">resume()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">entry</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> entry point taking one parameter and returning void. </td></tr>
    <tr><td class="paramname">param</td><td>Arbitrary pointer-sized value passed as the single parameter to the thread entry point. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
    <tr><td class="paramname">startImmediately</td><td>Whether the new thread will start to run automatically. If false, the thread will be created in a suspended state. The constants <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281a590fa4384d5ccce48ffaa15e5a81c973" title="Automatically run the thread. ">kArStartThread</a> and <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281ab4226c477d1366a9f2b96e0e407b8590" title="Create the thread suspended. ">kArSuspendThread</a> can be used to better document this parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a27e178199a575e82a814a560385d64f5" title="Operation was successful. ">kArSuccess</a></td><td>The thread was initialised without error. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a7910582dabf4bae4a35c182e77b2ce9d" title="Allocation failed. ">kArOutOfMemoryError</a></td><td>Failed to dynamically allocate the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdc0953b0f60d54b73f0cc71bec8fd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc0953b0f60d54b73f0cc71bec8fd76">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> Ar::Thread::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)()&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startImmediately</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer to set the thread entry to a member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">object</td><td>Pointer to an instance of class T upon which the <em>entry</em> member function will be invoked when the thread is started. </td></tr>
    <tr><td class="paramname">entry</td><td>Member function of class T that will be used as the thread's entry point. The member function must take no parameters and return void. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. If this parameter is NULL, the stack will be dynamically allocated. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
    <tr><td class="paramname">startImmediately</td><td>Whether the new thread will start to run automatically. If false, the thread will be created in a suspended state. The constants <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281a590fa4384d5ccce48ffaa15e5a81c973" title="Automatically run the thread. ">kArStartThread</a> and <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281ab4226c477d1366a9f2b96e0e407b8590" title="Create the thread suspended. ">kArSuspendThread</a> can be used to better document this parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a27e178199a575e82a814a560385d64f5" title="Operation was successful. ">kArSuccess</a></td><td>The thread was initialised without error. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a7910582dabf4bae4a35c182e77b2ce9d" title="Allocation failed. ">kArOutOfMemoryError</a></td><td>Failed to dynamically allocate the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83520b6fe067f7fa57addca8b6943716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83520b6fe067f7fa57addca8b6943716">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ar::Thread::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make the thread eligible for execution. </p>
<p>If the thread being resumed has a higher priority than that of the current thread, the scheduler is called to immediately switch threads. In this case the thread being resumed will always become the new current thread. This is because the highest priority thread is always guaranteed to be running, meaning the calling thread was the previous highest priority thread.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running. Does nothing if the thread is already on the ready list.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Deal with all thread states properly. </dd></dl>

</div>
</div>
<a id="a305a4155b282edbc7c995b956770d277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305a4155b282edbc7c995b956770d277">&#9670;&nbsp;</a></span>setPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> Ar::Thread::setPriority </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the thread's priority. </p>
<p>The scheduler is invoked after the priority is set so that the current thread can be changed to the one with the highest priority. The scheduler is invoked even if there is no new highest priority thread. In this case, control may switch to the next thread with the same priority, assuming there is one.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td><a class="el" href="class_ar_1_1_thread.html" title="Preemptive thread class. ">Thread</a> priority level from 1 to 255, where lower numbers have a lower priority. Priority number 0 is not allowed because it is reserved for the idle thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a27e178199a575e82a814a560385d64f5" title="Operation was successful. ">kArSuccess</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__ar.html#ggac7fd2dafb7c0b2dfd03e84537ebb3b16a77aae9af56299379a1ad7f7b1b813d2e" title="The requested thread priority is invalid. ">kArInvalidPriorityError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0014db107847869b311cf4deaac5585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0014db107847869b311cf4deaac5585">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ar::Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the current thread to sleep for a certain amount of time. </p>
<p>Does nothing if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to sleep the calling thread. A sleep time of 0 is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cf437dfe1fce2f17ca5223e611352ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf437dfe1fce2f17ca5223e611352ba">&#9670;&nbsp;</a></span>sleepUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ar::Thread::sleepUntil </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wakeup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put the current thread to sleep until a specific time. </p>
<p>Does nothing if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeup</td><td>The wakeup time in milliseconds. If the time is not in the future, i.e., less than or equal to the current value returned by <a class="el" href="group__ar__time.html#ga6ad60743dc94359da36268dee23b0566" title="Return the current time in milliseconds. ">ar_get_millisecond_count()</a>, then the sleep request is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a691d68343e01bae8e3b60d35efd4f1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691d68343e01bae8e3b60d35efd4f1bf">&#9670;&nbsp;</a></span>suspend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ar::Thread::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put thread in suspended state. </p>
<p>If this method is called from the current thread then the scheduler is entered immediately after putting the thread on the suspended list. Calling <a class="el" href="class_ar_1_1_thread.html#a691d68343e01bae8e3b60d35efd4f1bf" title="Put thread in suspended state. ">suspend()</a> on another thread will not cause the scheduler to switch threads.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running. Does nothing if the thread is already suspended.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Deal with all thread states properly. </dd></dl>

</div>
</div>
<a id="a99112d3407395ff4bd1384039f6d90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99112d3407395ff4bd1384039f6d90c3">&#9670;&nbsp;</a></span>threadEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ar::Thread::threadEntry </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual thread entry point. </p>
<p>This is the method that subclasses should override. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ar.html">Ar</a></li><li class="navelem"><a class="el" href="class_ar_1_1_thread.html">Thread</a></li>
    <li class="footer">Generated on Sat Apr 7 2018 15:03:03 for Argon RTOS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
