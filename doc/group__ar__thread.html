<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Argon RTOS: Threads</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Argon RTOS
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">Tiny embedded real-time kernel</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__ar__thread.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Threads<div class="ingroups"><a class="el" href="group__ar.html">Argon RTOS</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Threads:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__ar__thread.png" border="0" alt="" usemap="#group____ar____thread"/>
<map name="group____ar____thread" id="group____ar____thread">
<area shape="rect" id="node1" href="group__ar.html" title="Common definitions and kernel APIs. " alt="" coords="5,5,103,31"/>
</map>
</td></tr></table></center>
</div>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Thread API. </p>


<h3><a id="md_argon_threads"></a>argon_threads</h3><div class="textblock"><h3>Priorities</h3>
Thread priorities range from 0 to 255. Higher values are higher priorities, with 255 being the highest priority. Priority 0 is reserved for the idle thread. The highest priority thread that is ready to run will always get the processor. That means that if there is only one high priority thread, it can starve lower priority threads if it never relinquishes control by sleeping or blocking on a resource. Threads with the same priority will preempt each other in a round robin order every system tick.<h3>Encapsulated thread classes</h3>
If you want to fully encapsulate a thread you can create a subclass of Thread that provides its own init() method which calls the original Thread::init(). You can either pass a pointer to a static function to the base init() method, as usual, or you can override the virtual Thread::threadEntry() method. In the latter case, you can simply pass NULL for the entry point to the base init() method. To pass values to the thread function, simply create member variables and set them in your subclass' init() method.Here's an example subclass that uses a member function as the entry point: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MySubclassThread : <span class="keyword">public</span> <a class="code" href="class_ar_1_1_thread.html">Ar::Thread</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <a class="code" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> <a class="code" href="class_ar_1_1_thread.html#a545e5245ed44184e9ad54db769626258">init</a>()</div><div class="line">    {</div><div class="line">        <span class="comment">// Pass NULL for the entry point. It&#39;s not needed because you are</span></div><div class="line">        <span class="comment">// overriding threadEntry() below.</span></div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="class_ar_1_1_thread.html#a545e5245ed44184e9ad54db769626258">Thread::init</a>(<span class="stringliteral">&quot;my thread&quot;</span>, NULL, <span class="keyword">this</span>, m_stack, <span class="keyword">sizeof</span>(m_stack), 32);</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="comment">// Static memory for the stack.</span></div><div class="line">    uint8_t m_stack[4096];</div><div class="line"></div><div class="line">    <span class="comment">// Override the default Thread implementation.</span></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="class_ar_1_1_thread.html#a99112d3407395ff4bd1384039f6d90c3">threadEntry</a>()</div><div class="line">    {</div><div class="line">        <span class="comment">// Implement your thread here.</span></div><div class="line">    }</div><div class="line"></div><div class="line">};</div></div><!-- fragment --> </div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__ar__thread.html">ar_thread_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread.  <a href="struct__ar__thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structar__thread__status__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#structar__thread__status__t">ar_thread_status_t</a></td></tr>
<tr class="memdesc:structar__thread__status__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current status of a thread.  <a href="group__ar__thread.html#structar__thread__status__t">More...</a><br /></td></tr>
<tr class="separator:structar__thread__status__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread.html">Ar::Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preemptive thread class.  <a href="class_ar_1_1_thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ar_1_1_thread_with_stack.html">Ar::ThreadWithStack&lt; S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to create a thread and its stack.  <a href="class_ar_1_1_thread_with_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga4682233d934ce1bef0270631aeccbc6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga4682233d934ce1bef0270631aeccbc6e">_ar_thread_priorities</a> { <br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga4682233d934ce1bef0270631aeccbc6eaf3cd81c82b4403423832ee55fe4b6d3c">kArIdleThreadPriority</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga4682233d934ce1bef0270631aeccbc6eafc3310070c716ef1f89b94a6c7c5f34a">kArMinThreadPriority</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga4682233d934ce1bef0270631aeccbc6ea75e5c82b3cdc8951343bc51e568ab5b8">kArMaxThreadPriority</a>
<br />
 }</td></tr>
<tr class="memdesc:ga4682233d934ce1bef0270631aeccbc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of priorities for threads.  <a href="group__ar__thread.html#ga4682233d934ce1bef0270631aeccbc6e">More...</a><br /></td></tr>
<tr class="separator:ga4682233d934ce1bef0270631aeccbc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b32dd975769447d8a9e8cdf39e1f56"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a> { <br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga59b32dd975769447d8a9e8cdf39e1f56af96e6a3489aeb7dedce7f5c1b801eb3f">kArThreadUnknown</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga59b32dd975769447d8a9e8cdf39e1f56a8be8c2af9e4d05f20f8d811d436485cd">kArThreadSuspended</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga59b32dd975769447d8a9e8cdf39e1f56a16632e2cf1e6e5cb49d231e536c07b46">kArThreadReady</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga59b32dd975769447d8a9e8cdf39e1f56a2754a0920fba606d9936c40b771dae84">kArThreadRunning</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga59b32dd975769447d8a9e8cdf39e1f56af714ec0910d8166d4f051de2b2bb5e0e">kArThreadBlocked</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga59b32dd975769447d8a9e8cdf39e1f56a34abb7c29815b5a67fb41a6991d9fbb3">kArThreadSleeping</a>, 
<br />
&#160;&#160;<a class="el" href="group__ar__thread.html#gga59b32dd975769447d8a9e8cdf39e1f56ac26e72223f635e233c5f2da3b809ae1e">kArThreadDone</a>
<br />
 }</td></tr>
<tr class="memdesc:ga59b32dd975769447d8a9e8cdf39e1f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential thread states.  <a href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">More...</a><br /></td></tr>
<tr class="separator:ga59b32dd975769447d8a9e8cdf39e1f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Function types</h2></td></tr>
<tr class="memitem:ga79d9afd9054b840c52ce11a0e627cdc6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a>) (void *param)</td></tr>
<tr class="memdesc:ga79d9afd9054b840c52ce11a0e627cdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for the thread entry point.  <a href="#ga79d9afd9054b840c52ce11a0e627cdc6">More...</a><br /></td></tr>
<tr class="separator:ga79d9afd9054b840c52ce11a0e627cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Threads</h2></td></tr>
<tr class="memitem:ga4530eccba1cfbf1ddd5f097aa9255d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga4530eccba1cfbf1ddd5f097aa9255d5b">ar_thread_create</a> (ar_thread_t *thread, const char *name, <a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a> entry, void *param, void *stack, unsigned stackSize, uint8_t priority, bool startImmediately)</td></tr>
<tr class="memdesc:ga4530eccba1cfbf1ddd5f097aa9255d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <a href="#ga4530eccba1cfbf1ddd5f097aa9255d5b">More...</a><br /></td></tr>
<tr class="separator:ga4530eccba1cfbf1ddd5f097aa9255d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56aae03d241336b0f8909f6f1d5e2544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga56aae03d241336b0f8909f6f1d5e2544">ar_thread_delete</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:ga56aae03d241336b0f8909f6f1d5e2544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a thread.  <a href="#ga56aae03d241336b0f8909f6f1d5e2544">More...</a><br /></td></tr>
<tr class="separator:ga56aae03d241336b0f8909f6f1d5e2544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce207e46c46f0675122476eb23154fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga8ce207e46c46f0675122476eb23154fe">ar_thread_suspend</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:ga8ce207e46c46f0675122476eb23154fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put thread in suspended state.  <a href="#ga8ce207e46c46f0675122476eb23154fe">More...</a><br /></td></tr>
<tr class="separator:ga8ce207e46c46f0675122476eb23154fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ca7d8980d0cb08f450d57178dfbd544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga6ca7d8980d0cb08f450d57178dfbd544">ar_thread_resume</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:ga6ca7d8980d0cb08f450d57178dfbd544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the thread eligible for execution.  <a href="#ga6ca7d8980d0cb08f450d57178dfbd544">More...</a><br /></td></tr>
<tr class="separator:ga6ca7d8980d0cb08f450d57178dfbd544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7229bf7cc6a5548450d23ba4aa7f109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#gac7229bf7cc6a5548450d23ba4aa7f109">ar_thread_get_state</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:gac7229bf7cc6a5548450d23ba4aa7f109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current state of the thread.  <a href="#gac7229bf7cc6a5548450d23ba4aa7f109">More...</a><br /></td></tr>
<tr class="separator:gac7229bf7cc6a5548450d23ba4aa7f109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3346d7d30f584e52d0cb1b89503b23"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#gafd3346d7d30f584e52d0cb1b89503b23">ar_thread_get_priority</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:gafd3346d7d30f584e52d0cb1b89503b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread's current priority.  <a href="#gafd3346d7d30f584e52d0cb1b89503b23">More...</a><br /></td></tr>
<tr class="separator:gafd3346d7d30f584e52d0cb1b89503b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba32bad0bd938f460bcecb6538f8d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga5ba32bad0bd938f460bcecb6538f8d1a">ar_thread_set_priority</a> (ar_thread_t *thread, uint8_t newPriority)</td></tr>
<tr class="memdesc:ga5ba32bad0bd938f460bcecb6538f8d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change a thread's priority.  <a href="#ga5ba32bad0bd938f460bcecb6538f8d1a">More...</a><br /></td></tr>
<tr class="separator:ga5ba32bad0bd938f460bcecb6538f8d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2aaa0cd580d766e5f6ab47e5e0d70a"><td class="memItemLeft" align="right" valign="top">ar_thread_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#gacf2aaa0cd580d766e5f6ab47e5e0d70a">ar_thread_get_current</a> (void)</td></tr>
<tr class="memdesc:gacf2aaa0cd580d766e5f6ab47e5e0d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently running thread object.  <a href="#gacf2aaa0cd580d766e5f6ab47e5e0d70a">More...</a><br /></td></tr>
<tr class="separator:gacf2aaa0cd580d766e5f6ab47e5e0d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d2b32f368f9ed746cf120a433765c6"><td class="memItemLeft" align="right" valign="top">ar_runloop_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#gaf6d2b32f368f9ed746cf120a433765c6">ar_thread_get_runloop</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:gaf6d2b32f368f9ed746cf120a433765c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the runloop currently associated with the given thread.  <a href="#gaf6d2b32f368f9ed746cf120a433765c6">More...</a><br /></td></tr>
<tr class="separator:gaf6d2b32f368f9ed746cf120a433765c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ae215f644f24313ffaa13389e07019"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga01ae215f644f24313ffaa13389e07019">ar_thread_sleep</a> (uint32_t milliseconds)</td></tr>
<tr class="memdesc:ga01ae215f644f24313ffaa13389e07019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep for a certain amount of time.  <a href="#ga01ae215f644f24313ffaa13389e07019">More...</a><br /></td></tr>
<tr class="separator:ga01ae215f644f24313ffaa13389e07019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga659b354cf4eda03b08df59493d72a1e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga659b354cf4eda03b08df59493d72a1e1">ar_thread_sleep_until</a> (uint32_t wakeup)</td></tr>
<tr class="memdesc:ga659b354cf4eda03b08df59493d72a1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the current thread to sleep until a specific time.  <a href="#ga659b354cf4eda03b08df59493d72a1e1">More...</a><br /></td></tr>
<tr class="separator:ga659b354cf4eda03b08df59493d72a1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae823dc0331afbf56d00e689284d7e5ed"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#gae823dc0331afbf56d00e689284d7e5ed">ar_thread_get_name</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:gae823dc0331afbf56d00e689284d7e5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's name.  <a href="#gae823dc0331afbf56d00e689284d7e5ed">More...</a><br /></td></tr>
<tr class="separator:gae823dc0331afbf56d00e689284d7e5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d40cc82e67316cbc559241ec5a3f2ef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga8d40cc82e67316cbc559241ec5a3f2ef">ar_thread_get_load</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:ga8d40cc82e67316cbc559241ec5a3f2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of CPU time the thread is using.  <a href="#ga8d40cc82e67316cbc559241ec5a3f2ef">More...</a><br /></td></tr>
<tr class="separator:ga8d40cc82e67316cbc559241ec5a3f2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c85e1a114caa108bb7807a0ccba3bb0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga9c85e1a114caa108bb7807a0ccba3bb0">ar_thread_get_stack_used</a> (ar_thread_t *thread)</td></tr>
<tr class="memdesc:ga9c85e1a114caa108bb7807a0ccba3bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum stack usage of the specified thread.  <a href="#ga9c85e1a114caa108bb7807a0ccba3bb0">More...</a><br /></td></tr>
<tr class="separator:ga9c85e1a114caa108bb7807a0ccba3bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb5fcb95eda3339edd82061012586a3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ar__thread.html#ga1cb5fcb95eda3339edd82061012586a3">ar_thread_get_report</a> (<a class="el" href="group__ar__thread.html#structar__thread__status__t">ar_thread_status_t</a> report[], uint32_t maxEntries)</td></tr>
<tr class="memdesc:ga1cb5fcb95eda3339edd82061012586a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a report of all thread's status.  <a href="#ga1cb5fcb95eda3339edd82061012586a3">More...</a><br /></td></tr>
<tr class="separator:ga1cb5fcb95eda3339edd82061012586a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structar__thread__status__t" id="structar__thread__status__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structar__thread__status__t">&#9670;&nbsp;</a></span>ar_thread_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ar_thread_status_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a427242055e2db1d82a3ec0ebb68b5103"></a>uint32_t</td>
<td class="fieldname">
m_cpu</td>
<td class="fielddoc">
Per mille CPU usage of the thread over the last sampling period, with a range of 1-1000. </td></tr>
<tr><td class="fieldtype">
<a id="a610a11a9183de635814006681298d191"></a>uint32_t</td>
<td class="fieldname">
m_maxStackUsed</td>
<td class="fielddoc">
Maximum number of bytes used in the thread's stack. </td></tr>
<tr><td class="fieldtype">
<a id="a5f990424c707cb09631332e760c8308c"></a>const char *</td>
<td class="fieldname">
m_name</td>
<td class="fielddoc">
Thread's name. </td></tr>
<tr><td class="fieldtype">
<a id="aa45cfce41d4e041ceb0ac03777fc1dc3"></a>uint32_t</td>
<td class="fieldname">
m_stackSize</td>
<td class="fielddoc">
Total bytes allocated to the thread's stack. </td></tr>
<tr><td class="fieldtype">
<a id="ab367f9bd1c4f8920d9e1e23265d3cc32"></a><a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a></td>
<td class="fieldname">
m_state</td>
<td class="fielddoc">
Current thread state. </td></tr>
<tr><td class="fieldtype">
<a id="ae6f6dd1d03a2ef6fafb0169a9859cce0"></a>ar_thread_t *</td>
<td class="fieldname">
m_thread</td>
<td class="fielddoc">
Pointer to the thread's structure. </td></tr>
<tr><td class="fieldtype">
<a id="a61ec8bc37175c85ab42ef9897a2d59b3"></a>uint32_t</td>
<td class="fieldname">
m_uniqueId</td>
<td class="fielddoc">
Unique ID for this thread. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga79d9afd9054b840c52ce11a0e627cdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d9afd9054b840c52ce11a0e627cdc6">&#9670;&nbsp;</a></span>ar_thread_entry_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ar_thread_entry_t) (void *param)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype for the thread entry point. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga4682233d934ce1bef0270631aeccbc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4682233d934ce1bef0270631aeccbc6e">&#9670;&nbsp;</a></span>_ar_thread_priorities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ar__thread.html#ga4682233d934ce1bef0270631aeccbc6e">_ar_thread_priorities</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range of priorities for threads. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4682233d934ce1bef0270631aeccbc6eaf3cd81c82b4403423832ee55fe4b6d3c"></a>kArIdleThreadPriority&#160;</td><td class="fielddoc"><p>The idle thread's priority. No other thread is allowed to have this priority. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4682233d934ce1bef0270631aeccbc6eafc3310070c716ef1f89b94a6c7c5f34a"></a>kArMinThreadPriority&#160;</td><td class="fielddoc"><p>Priority value for the lowest priority user thread. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4682233d934ce1bef0270631aeccbc6ea75e5c82b3cdc8951343bc51e568ab5b8"></a>kArMaxThreadPriority&#160;</td><td class="fielddoc"><p>Priority value for the highest priority user thread. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga59b32dd975769447d8a9e8cdf39e1f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59b32dd975769447d8a9e8cdf39e1f56">&#9670;&nbsp;</a></span>ar_thread_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Potential thread states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga59b32dd975769447d8a9e8cdf39e1f56af96e6a3489aeb7dedce7f5c1b801eb3f"></a>kArThreadUnknown&#160;</td><td class="fielddoc"><p>Hopefully a thread is never in this state. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga59b32dd975769447d8a9e8cdf39e1f56a8be8c2af9e4d05f20f8d811d436485cd"></a>kArThreadSuspended&#160;</td><td class="fielddoc"><p>Thread is not eligible for execution. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga59b32dd975769447d8a9e8cdf39e1f56a16632e2cf1e6e5cb49d231e536c07b46"></a>kArThreadReady&#160;</td><td class="fielddoc"><p>Thread is eligible to be run. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga59b32dd975769447d8a9e8cdf39e1f56a2754a0920fba606d9936c40b771dae84"></a>kArThreadRunning&#160;</td><td class="fielddoc"><p>The thread is currently running. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga59b32dd975769447d8a9e8cdf39e1f56af714ec0910d8166d4f051de2b2bb5e0e"></a>kArThreadBlocked&#160;</td><td class="fielddoc"><p>The thread is blocked on another object. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga59b32dd975769447d8a9e8cdf39e1f56a34abb7c29815b5a67fb41a6991d9fbb3"></a>kArThreadSleeping&#160;</td><td class="fielddoc"><p>Thread is sleeping. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga59b32dd975769447d8a9e8cdf39e1f56ac26e72223f635e233c5f2da3b809ae1e"></a>kArThreadDone&#160;</td><td class="fielddoc"><p>Thread has exited. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4530eccba1cfbf1ddd5f097aa9255d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4530eccba1cfbf1ddd5f097aa9255d5b">&#9670;&nbsp;</a></span>ar_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> ar_thread_create </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#ga79d9afd9054b840c52ce11a0e627cdc6">ar_thread_entry_t</a>&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startImmediately</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<p>The state of the new thread is determined by the <em>startImmediately</em> parameter. If true, the thread is created in the ready state. Otherwise, the thread is suspended when this function exits. In this case, to make it eligible for execution you must call the <a class="el" href="group__ar__thread.html#ga6ca7d8980d0cb08f450d57178dfbd544" title="Make the thread eligible for execution. ">ar_thread_resume()</a> function. When <em>startImmediately</em> is true, the new thread may start execution before this function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to the thread structure. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the thread. If NULL, the thread's name is set to an empty string. </td></tr>
    <tr><td class="paramname">entry</td><td>Thread entry point taking one parameter and returning void. </td></tr>
    <tr><td class="paramname">param</td><td>Arbitrary pointer-sized value passed as the single parameter to the thread entry point. </td></tr>
    <tr><td class="paramname">stack</td><td>Pointer to the start of the thread's stack. This should be the stack's bottom, not it's top. </td></tr>
    <tr><td class="paramname">stackSize</td><td>Number of bytes of stack space allocated to the thread. This value is added to <em>stack</em> to get the initial top of stack address. </td></tr>
    <tr><td class="paramname">priority</td><td>Thread priority. The accepted range is 1 through 255. Priority 0 is reserved for the idle thread. </td></tr>
    <tr><td class="paramname">startImmediately</td><td>Whether the new thread will start to run automatically. If false, the thread will be created in a suspended state. The constants <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281a590fa4384d5ccce48ffaa15e5a81c973" title="Automatically run the thread. ">kArStartThread</a> and <a class="el" href="ar__kernel_8h.html#ab52c5b183284b45dae2c8c8d7aeb4281ab4226c477d1366a9f2b96e0e407b8590" title="Create the thread suspended. ">kArSuspendThread</a> can be used to better document this parameter value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kArSuccess The thread was initialised without error. </dd></dl>

</div>
</div>
<a id="ga56aae03d241336b0f8909f6f1d5e2544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56aae03d241336b0f8909f6f1d5e2544">&#9670;&nbsp;</a></span>ar_thread_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> ar_thread_delete </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to the thread structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf2aaa0cd580d766e5f6ab47e5e0d70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf2aaa0cd580d766e5f6ab47e5e0d70a">&#9670;&nbsp;</a></span>ar_thread_get_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ar_thread_t* ar_thread_get_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the currently running thread object. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the current thread's structure. </dd></dl>

</div>
</div>
<a id="ga8d40cc82e67316cbc559241ec5a3f2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d40cc82e67316cbc559241ec5a3f2ef">&#9670;&nbsp;</a></span>ar_thread_get_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ar_thread_get_load </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the amount of CPU time the thread is using. </p>
<p>Thread CPU usage is computed once every second for all threads.</p>
<dl class="section return"><dt>Returns</dt><dd>Per mille of CPU load for the given thread. Value is 0-1000. </dd></dl>

</div>
</div>
<a id="gae823dc0331afbf56d00e689284d7e5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae823dc0331afbf56d00e689284d7e5ed">&#9670;&nbsp;</a></span>ar_thread_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ar_thread_get_name </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's name. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the name of the thread. </dd></dl>

</div>
</div>
<a id="gafd3346d7d30f584e52d0cb1b89503b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd3346d7d30f584e52d0cb1b89503b23">&#9670;&nbsp;</a></span>ar_thread_get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ar_thread_get_priority </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread's current priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to the thread structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cb5fcb95eda3339edd82061012586a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cb5fcb95eda3339edd82061012586a3">&#9670;&nbsp;</a></span>ar_thread_get_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ar_thread_get_report </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ar__thread.html#structar__thread__status__t">ar_thread_status_t</a>&#160;</td>
          <td class="paramname"><em>report</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxEntries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a report of all thread's status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Report</td><td>array to be filled in. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxEntries</td><td>Maximum number of thread status that can be placed into <em>report</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual number of threads filled in to <em>report</em>. </dd></dl>

</div>
</div>
<a id="gaf6d2b32f368f9ed746cf120a433765c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6d2b32f368f9ed746cf120a433765c6">&#9670;&nbsp;</a></span>ar_thread_get_runloop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ar_runloop_t* ar_thread_get_runloop </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the runloop currently associated with the given thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the runloop runnning on the thread, if there is one. If there is not an associated runloop, then NULL will be returned. </dd></dl>

</div>
</div>
<a id="ga9c85e1a114caa108bb7807a0ccba3bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c85e1a114caa108bb7807a0ccba3bb0">&#9670;&nbsp;</a></span>ar_thread_get_stack_used()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ar_thread_get_stack_used </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum stack usage of the specified thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to inspect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of bytes used in the thread's stack, rounded down to the nearest word. If the thread has overflowed its stack, then 0 will be returned. </dd></dl>

</div>
</div>
<a id="gac7229bf7cc6a5548450d23ba4aa7f109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7229bf7cc6a5548450d23ba4aa7f109">&#9670;&nbsp;</a></span>ar_thread_get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar__thread.html#ga59b32dd975769447d8a9e8cdf39e1f56">ar_thread_state_t</a> ar_thread_get_state </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current state of the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to the thread structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ca7d8980d0cb08f450d57178dfbd544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca7d8980d0cb08f450d57178dfbd544">&#9670;&nbsp;</a></span>ar_thread_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> ar_thread_resume </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the thread eligible for execution. </p>
<p>If the thread being resumed has a higher priority than that of the current thread, the scheduler is called to immediately switch threads. In this case the thread being resumed will always become the new current thread. This is because the highest priority thread is always guaranteed to be running, meaning the calling thread was the previous highest priority thread.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running. Does nothing if the thread is already on the ready list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to the thread structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ba32bad0bd938f460bcecb6538f8d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ba32bad0bd938f460bcecb6538f8d1a">&#9670;&nbsp;</a></span>ar_thread_set_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> ar_thread_set_priority </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>newPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change a thread's priority. </p>
<p>The scheduler is invoked after the priority is set so that the current thread can be changed to the one with the highest priority. The scheduler is invoked even if there is no new highest priority thread. In this case, control may switch to the next thread with the same priority, assuming there is one.</p>
<p>Does not enter the scheduler if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to the thread structure. </td></tr>
    <tr><td class="paramname">newPriority</td><td>Thread priority level from 1 to 255, where lower numbers have a lower priority. Priority number 0 is not allowed because it is reserved for the idle thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kArSuccess</td><td></td></tr>
    <tr><td class="paramname">kArInvalidPriorityError</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga01ae215f644f24313ffaa13389e07019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ae215f644f24313ffaa13389e07019">&#9670;&nbsp;</a></span>ar_thread_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ar_thread_sleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the current thread to sleep for a certain amount of time. </p>
<p>Does nothing if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<p>A sleeping thread can be woken early by calling <a class="el" href="group__ar__thread.html#ga6ca7d8980d0cb08f450d57178dfbd544" title="Make the thread eligible for execution. ">ar_thread_resume()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to sleep the calling thread. A sleep time of 0 is ignored. If <a class="el" href="group__ar.html#gga7d3f0ad0bcc755713601ba6edb75dd0faef3a89f97ff0d9f673394d645f9baf43" title="Pass this value to wait forever to acquire a resource. ">kArInfiniteTimeout</a> is passed for the sleep time, the thread will simply be suspended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga659b354cf4eda03b08df59493d72a1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga659b354cf4eda03b08df59493d72a1e1">&#9670;&nbsp;</a></span>ar_thread_sleep_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ar_thread_sleep_until </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the current thread to sleep until a specific time. </p>
<p>Does nothing if <a class="el" href="namespace_ar.html" title="The Argon RTOS namespace. ">Ar</a> is not running.</p>
<p>A sleeping thread can be woken early by calling <a class="el" href="group__ar__thread.html#ga6ca7d8980d0cb08f450d57178dfbd544" title="Make the thread eligible for execution. ">ar_thread_resume()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeup</td><td>The wakeup time in milliseconds. If the time is not in the future, i.e., less than or equal to the current value returned by <a class="el" href="group__ar__time.html#ga6ad60743dc94359da36268dee23b0566" title="Return the current time in milliseconds. ">ar_get_millisecond_count()</a>, then the sleep request is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ce207e46c46f0675122476eb23154fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce207e46c46f0675122476eb23154fe">&#9670;&nbsp;</a></span>ar_thread_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ar.html#gac7fd2dafb7c0b2dfd03e84537ebb3b16">ar_status_t</a> ar_thread_suspend </td>
          <td>(</td>
          <td class="paramtype">ar_thread_t *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put thread in suspended state. </p>
<p>If this function is called from the current thread then the scheduler is entered immediately after putting the thread on the suspended list. Calling this function on another thread will not cause the scheduler to switch threads.</p>
<p>Does not enter the scheduler if the kernel is not running. Does nothing if the thread is already suspended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Pointer to the thread structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Apr 7 2018 15:03:02 for Argon RTOS by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
